#include "w3d.h"
#include "binary_io.h"
#include "container_utils.h"

#include <cassert>
#include <iostream>
#include <filesystem>
#include <chrono>

const std::unordered_map<uint32_t, ChunkType>
Asset::Chunk::PRIMARY_CHUNKS
{
    {0x00'54'45'58 /*TEX*/, ChunkType::W3D_TEXTURE_FILE},
    {0x4d'45'53'48 /*MESH*/, ChunkType::W3D_CHUNK_MESH},
    {0x48'49'45'52 /*HIER*/, ChunkType::W3D_CHUNK_HIERARCHY},
    {0x41'4e'49'4d /*ANIM*/, ChunkType::W3D_CHUNK_ANIMATION},
    {0x50'41'52'54 /*PART*/, ChunkType::W3D_CHUNK_EMITTER},
    {0x41'47'47'52 /*AGGR*/, ChunkType::W3D_CHUNK_AGGREGATE},
    {0x48'4c'4f'44 /*HLOD*/, ChunkType::W3D_CHUNK_HLOD},
    {0x00'42'4f'58 /*BOX*/, ChunkType::W3D_CHUNK_BOX}
};

const std::unordered_map<ChunkType, uint32_t>
Asset::Chunk::PRIMARY_CHUNKS_INV
{
    {ChunkType::W3D_TEXTURE_FILE, /*TEX*/ 0x00'54'45'58},
    {ChunkType::W3D_CHUNK_MESH, /*MESH*/ 0x4d'45'53'48},
    {ChunkType::W3D_CHUNK_HIERARCHY, /*HIER*/ 0x48'49'45'52},
    {ChunkType::W3D_CHUNK_ANIMATION, /*ANIM*/ 0x41'4e'49'4d},
    {ChunkType::W3D_CHUNK_COMPRESSED_ANIMATION, /*ANIM*/ 0x41'4e'49'4d},
    {ChunkType::W3D_CHUNK_EMITTER, /*PART*/ 0x50'41'52'54},
    {ChunkType::W3D_CHUNK_AGGREGATE, /*AGGR*/ 0x41'47'47'52},
    {ChunkType::W3D_CHUNK_HLOD, /*HLOD*/ 0x48'4c'4f'44},
    {ChunkType::W3D_CHUNK_BOX, /*BOX*/ 0x00'42'4f'58 }
};

template <typename T>
T ReadChunkSize(std::ifstream& ifs)
{
    T out = ReadPrimitive<T>(ifs);

    /* Chopping off the leading byte, which is reserved to 
    indicate whether there are sub-chunks */
    ((char*)&out)[sizeof(out) - 1] &= 0x0f;
    return out;
}

void Asset::Chunk::ReadInfoDat(augmented::ifstream& ifs)
{
    name = ReadShortString(ifs.FS());

    {
        uint32_t fixed_type = ReadPrimitive<uint32_t>(ifs.FS());

        /* Fixing a stray byte in BOX chunks from a .dat file 
        generated by AssetBuilder. */
        ((char*)&fixed_type)[3] = (((char*)&fixed_type)[2] == 'B')
            ? '\0' : ((char*)&fixed_type)[3];
        
        type = PRIMARY_CHUNKS.at(fixed_type);   
    }

    offset = ReadPrimitive<uint32_t>(ifs.FS());
    size = ReadPrimitive<uint32_t>(ifs.FS());
}

void Asset::Chunk::ReadInfoW3D(augmented::ifstream& ifs)
{
    offset = ifs.FS().tellg();
    type = (ChunkType)ReadPrimitive<uint32_t>(ifs.FS());
    
    switch (type)
    {
    case ChunkType::W3D_CHUNK_MESH:
        ReadMesh(ifs.FS());
        break;

    case ChunkType::W3D_CHUNK_HIERARCHY:
        ReadHierarchy(ifs.FS());
        break;

    case ChunkType::W3D_CHUNK_ANIMATION:
        ReadAnimation(ifs.FS());
        break;
    
    case ChunkType::W3D_CHUNK_COMPRESSED_ANIMATION:
        ReadCompressedAnimation(ifs.FS());
        break;

    case ChunkType::W3D_CHUNK_EMITTER:
        ReadEmitter(ifs.FS());
        break;

    case ChunkType::W3D_CHUNK_AGGREGATE:
        ReadAggregate(ifs.FS());
        break;
    
    case ChunkType::W3D_CHUNK_HLOD:
        ReadHLoD(ifs.FS());
        break;
    
    case ChunkType::W3D_CHUNK_BOX:
        ReadBox(ifs.FS());
        break;

    default:
        Skip(ifs.FS());
        throw std::runtime_error("Unsupported chunk type encountered: ");
    }

    // Translating all input names into the lower register
    for (std::string& input_name : inputs)
    {
        for (char& c : input_name) c = std::tolower(c);
    }
    
    // Sorting the vector of inputs
    QuickSort(inputs.begin(), inputs.end());

    SetUpValidities();
}

void Asset::Chunk::Skip(std::ifstream& ifs)
{
    uint32_t chunk_size = ReadChunkSize<uint32_t>(ifs);
    ifs.seekg(chunk_size, std::ios::cur);
}

template <typename Fn>
void Asset::Chunk::ReadHeader(std::ifstream& ifs, 
    ChunkType exp_header_type, 
    uint32_t exp_header_size, 
    uint32_t min_version, 
    Fn&& fn, 
    uint8_t name_offset)
{
    {
        // The header must be of the correct type
        uint32_t header_type = ReadPrimitive<uint32_t>(ifs);
        if (header_type != (uint32_t)exp_header_type)
        {
            throw invalid_file_format("Chunk header is expected: ");
        }
    }

    {
        // The header must have a fixed size
        uint32_t header_size = ReadChunkSize<uint32_t>(ifs);
        if (header_size != exp_header_size)
        {
            throw invalid_file_format("Unexpected size of the chunk header: ");
        }
    }
    
    uint32_t header_offset = ifs.tellg();

    {
        // Older versions might be unsupported
        uint32_t header_version = ReadChunkSize<uint32_t>(ifs);
        if (header_version < min_version)
        {
            throw invalid_file_format("Unsupported chunk version: ");
        }
    }

    // Skipping attributes or whatever it is before the name begins
    ifs.seekg(name_offset, std::ios::cur);

    fn();

    // Skipping the rest of the header
    ifs.seekg(header_offset + exp_header_size);
}

void Asset::Chunk::ReadHeaderName(std::ifstream& ifs, 
    ChunkType exp_header_type, 
    uint32_t exp_header_size, 
    uint32_t exp_version, 
    uint8_t name_offset)
{
    ReadHeader(ifs, 
        exp_header_type, exp_header_size, exp_version, 
        [this, &ifs]()
        {
            name = ReadFixedSizeString(ifs, W3D_MAX_STRING_LENGTH);
        }, 
        name_offset);
}

template <typename Fn>
void Asset::Chunk::ReadFromSubChunks(std::ifstream& ifs, 
    uint32_t end_pos, 
    ChunkType exp_chunk_type, 
    Fn&& fn)
{
    while (ifs.tellg() < end_pos)
    {
        uint32_t type = ReadPrimitive<uint32_t>(ifs);

        if (type == (uint32_t)exp_chunk_type) fn();
        else Skip(ifs);
    };
}

void Asset::Chunk::ReadMesh(std::ifstream& ifs)
{
    /* Gross size accounting for 4 + 4 bytes used for 
    the type and the size */
    size = ReadChunkSize<uint32_t>(ifs) + 0x08;

    ReadHeader(ifs, 
        ChunkType::W3D_CHUNK_MESH_HEADER3, 
        0x74, 0x00'04'00'02,  
        [this, &ifs]()
        {
            ifs.seekg(0x04, std::ios::cur); // skipping attributes

            std::string full_name;
            full_name.reserve(2 * W3D_MAX_STRING_LENGTH + 1); // +1 accounts for the separating '.'

            std::string mesh_name = ReadFixedSizeString(ifs, W3D_MAX_STRING_LENGTH);
            std::string container_name = ReadFixedSizeString(ifs, W3D_MAX_STRING_LENGTH);

            full_name += std::move(container_name);
            if (container_name.size()) full_name += '.';
            full_name += std::move(mesh_name);

            name = std::move(full_name);
        });

    ReadFromSubChunks(ifs, offset + size, 
        ChunkType::W3D_CHUNK_TEXTURES, 
        [this, &ifs]() { ReadMeshTextures(ifs); });
    
    // Skipping whatever else is there
    ifs.seekg(offset + size);
}

void Asset::Chunk::ReadMeshTextures(std::ifstream& ifs)
{
    uint32_t chunk_size = ReadChunkSize<uint32_t>(ifs);
    uint32_t chunk_offset = ifs.tellg();

    // Scans a texture chunk, adds the name to the vector of inputs
    ReadFromSubChunks(ifs, chunk_offset + chunk_size, 
        ChunkType::W3D_CHUNK_TEXTURE, 
        [this, &ifs]()
        {
            uint32_t chunk_size = ReadChunkSize<uint32_t>(ifs);
            uint32_t chunk_offset = ifs.tellg();
            
            while (ifs.tellg() < chunk_offset + chunk_size)
            {
                uint32_t sub_chunk_type = ReadPrimitive<uint32_t>(ifs);
                
                if (sub_chunk_type == (uint32_t)ChunkType::W3D_CHUNK_TEXTURE_NAME)
                {
                    uint32_t sub_chunk_size = ReadChunkSize<uint32_t>(ifs);
                    std::string texture_name = ReadFixedSizeString(ifs, sub_chunk_size);
                    inputs.emplace_back(std::move(texture_name));
                }
                else Skip(ifs);
            }
        });
}

void Asset::Chunk::ReadHierarchy(std::ifstream& ifs)
{
    /* Gross size accounting for 4 + 4 bytes used for 
    the type and the size */
    size = ReadChunkSize<uint32_t>(ifs) + 0x08;

    ReadHeader(ifs, 
        ChunkType::W3D_CHUNK_HIERARCHY_HEADER, 
        0x24, 0x00'04'00'01, 
        [this, &ifs]()
        {
            std::string full_name = "H*";
            full_name += ReadFixedSizeString(ifs, W3D_MAX_STRING_LENGTH);
            name = std::move(full_name);
        });
    
    // Skipping whatever else is there
    ifs.seekg(offset + size);
}

void Asset::Chunk::ReadAnimation(std::ifstream& ifs)
{
    /* Gross size accounting for 4 + 4 bytes used for 
    the type and the size */
    size = ReadChunkSize<uint32_t>(ifs) + 0x08;

    ReadHeader(ifs, 
        ChunkType::W3D_CHUNK_ANIMATION_HEADER, 
        0x2c, 0x00'04'00'01, 
        [this, &ifs]()
        {
            std::string full_name;
            full_name.reserve(2 * W3D_MAX_STRING_LENGTH + 3); // +3 accounts for "A*" and '.'

            std::string anim_name = ReadFixedSizeString(ifs, W3D_MAX_STRING_LENGTH);
            std::string hier_name = ReadFixedSizeString(ifs, W3D_MAX_STRING_LENGTH);

            full_name += "A*";
            full_name += std::move(hier_name);
            full_name += '.';
            full_name += std::move(anim_name);

            name = std::move(full_name);
        });
    
    // Skipping whatever else is there
    ifs.seekg(offset + size);
}

void Asset::Chunk::ReadCompressedAnimation(std::ifstream& ifs)
{
    /* Gross size accounting for 4 + 4 bytes used for 
    the type and the size */
    size = ReadChunkSize<uint32_t>(ifs) + 0x08;

    ReadHeader(ifs, 
        ChunkType::W3D_CHUNK_COMPRESSED_ANIMATION_HEADER, 
        0x2c, 0x00'00'00'01, 
        [this, &ifs]()
        {
            std::string full_name;
            full_name.reserve(2 * W3D_MAX_STRING_LENGTH + 3); // +3 accounts for "A*" and '.'

            std::string anim_name = ReadFixedSizeString(ifs, W3D_MAX_STRING_LENGTH);
            std::string hier_name = ReadFixedSizeString(ifs, W3D_MAX_STRING_LENGTH);

            full_name += "A*";
            full_name += std::move(hier_name);
            full_name += '.';
            full_name += std::move(anim_name);

            name = std::move(full_name);
        });
    
    // Skipping whatever else is there
    ifs.seekg(offset + size);
}

void Asset::Chunk::ReadEmitter(std::ifstream& ifs)
{
    /* Gross size accounting for 4 + 4 bytes used for 
    the type and the size */
    size = ReadChunkSize<uint32_t>(ifs) + 0x08;

    ReadHeaderName(ifs, 
        ChunkType::W3D_CHUNK_EMITTER_HEADER, 
        0x14, 0x00'02'00'00);
    
    // Scans an emitter info chunk, extracts the name of the texture
    ReadFromSubChunks(ifs, offset + size, 
        ChunkType::W3D_CHUNK_EMITTER_INFO, 
        [this, &ifs]()
        {
            uint32_t chunk_size = ReadChunkSize<uint32_t>(ifs);
            uint32_t chunk_offset = ifs.tellg();
            
            std::string texture_name = ReadFixedSizeString(ifs, 
                MAX_SHORT_STRING_LENGTH);
            
            inputs.emplace_back(std::move(texture_name));

            // Skipping whatever else is there
            ifs.seekg(offset + size);
        });
    
    // Skipping whatever else is there
    ifs.seekg(offset + size);
}

void Asset::Chunk::ReadAggregate(std::ifstream& ifs)
{
    /* Gross size accounting for 4 + 4 bytes used for 
    the type and the size */
    size = ReadChunkSize<uint32_t>(ifs) + 0x08;

    ReadHeaderName(ifs, 
        ChunkType::W3D_CHUNK_AGGREGATE_HEADER,
        0x14, 0x00'01'00'03);
    
    // Extracting input chunks from other assets
    ReadFromSubChunks(ifs, offset + size, 
        ChunkType::W3D_CHUNK_AGGREGATE_INFO, 
        [this, &ifs]()
        {
            uint32_t chunk_size = ReadChunkSize<uint32_t>(ifs);
            uint32_t chunk_offset = ifs.tellg();
            
            /* The name of the base chunk from a different file, 
            to whose bones sub-objects are attached */
            inputs.emplace_back(ReadFixedSizeString(ifs, 
                2 * W3D_MAX_STRING_LENGTH));
            
            uint32_t n_inputs = ReadPrimitive<uint32_t>(ifs);

            inputs.reserve(inputs.size() + n_inputs);

            for (uint32_t i = 0; i < n_inputs; ++i)
            {
                // The name of a sub-object
                inputs.emplace_back(ReadFixedSizeString(ifs, 
                    2 * W3D_MAX_STRING_LENGTH));
                
                // The name of the attachment bone is skipped...
                ifs.seekg(2 * W3D_MAX_STRING_LENGTH);
            }

            // Skipping whatever else is there
            ifs.seekg(chunk_offset + chunk_size);
        });
    
    // Skipping whatever else is there
    ifs.seekg(offset + size);
}

void Asset::Chunk::ReadHLoD(std::ifstream& ifs)
{
    using namespace std::string_literals;

    /* Gross size accounting for 4 + 4 bytes used for 
    the type and the size */
    size = ReadChunkSize<uint32_t>(ifs) + 0x08;

    ReadHeader(ifs, ChunkType::W3D_CHUNK_HLOD_HEADER, 
        0x28, 0x00'01'00'00, 
        [this, &ifs]()
        {
            ifs.seekg(0x04, std::ios::cur); // skipping attributes

            name = ReadFixedSizeString(ifs, W3D_MAX_STRING_LENGTH);
            std::string hier_name = 
                ReadFixedSizeString(ifs, W3D_MAX_STRING_LENGTH);
            
            if (hier_name.size())
            {
                inputs.emplace_back("H*"s + 
                    std::move(hier_name));
            }
        });

    ReadFromSubChunks(ifs, offset + size, 
        ChunkType::W3D_CHUNK_HLOD_LOD_ARRAY, 
        [this, &ifs]()
        {
            Chunk::ReadHLoDSubObjects(ifs);
        });
    
    // Skipping whatever else is there
    ifs.seekg(offset + size);
}

void Asset::Chunk::ReadHLoDSubObjects(std::ifstream& ifs)
{
    uint32_t chunk_size = ReadChunkSize<uint32_t>(ifs);
    uint32_t chunk_offset = ifs.tellg();

    ReadFromSubChunks(ifs, 
        chunk_offset + chunk_size, 
        ChunkType::W3D_CHUNK_HLOD_SUB_OBJECT, 
        [this, &ifs]()
        {
            uint32_t exp_chunk_size = 0x24;
            uint32_t chunk_size = ReadChunkSize<uint32_t>(ifs);
            uint32_t chunk_offset = ifs.tellg();

            if (chunk_size != exp_chunk_size)
            {
                throw invalid_file_format("HLoD sub-object is corrupted: ");
            }

            ifs.seekg(0x04, std::ios::cur); // skipping the bone index
            
            inputs.emplace_back(ReadFixedSizeString(ifs, 
                2 * W3D_MAX_STRING_LENGTH));

            ifs.seekg(chunk_offset + chunk_size);
        });
}

void Asset::Chunk::ReadBox(std::ifstream& ifs)
{
    size = ReadChunkSize<uint32_t>(ifs) + 0x08;

    ifs.seekg(0x04, std::ios::cur); // skipping version
    ifs.seekg(0x04, std::ios::cur); // skipping attributes

    name = ReadFixedSizeString(ifs, 
        2 * W3D_MAX_STRING_LENGTH);

    ifs.seekg(offset + size);
}

Asset::Chunk::Chunk(Chunk&& other) noexcept
{
    swap(other);
}

Asset::Chunk::Chunk(augmented::ifstream& ifs)
{
    /* No checks, since they are made when
    the containing asset is constructed */

    using namespace std::string_view_literals;
    
    std::string_view ext = ifs.FilePath();
    ext = ext.substr(ext.size() - 4);

    if (ext == ".dat"sv) ReadInfoDat(ifs);
    else if (ext == ".w3d"sv) ReadInfoW3D(ifs);
}

void Asset::Chunk::swap(Chunk& other)
{
    std::swap(name, other.name);
    std::swap(type, other.type);
    std::swap(offset, other.offset);
    std::swap(size, other.size);

    std::swap(inputs, other.inputs);
    std::swap(validities, other.validities);
}

void Asset::Chunk::SetUpValidities()
{
    validities = std::vector<bool>(inputs.capacity(), true);
}

bool Asset::Chunk::IsValidInput(size_t i) const
{
    return validities[i];
}

void Asset::Chunk::ValidateInput(size_t i)
{
    validities[i] = true;
}

void Asset::Chunk::InvalidateInput(size_t i)
{
    validities[i] = false;
}

augmented::ifstream& 
Asset::Chunk::operator>>(augmented::ifstream& ifs)
{
    Chunk temp(ifs);
    swap(temp);
    return ifs;
}

augmented::ifstream& 
operator>>(augmented::ifstream& ifs, Asset::Chunk& chunk)
{
    return chunk.operator>>(ifs);
}

std::ofstream& Asset::Chunk::operator<<(std::ofstream& ofs) const
{
    // Other chunks are not printed
    std::unordered_map<ChunkType, uint32_t>::const_iterator pos;
    pos = PRIMARY_CHUNKS_INV.find(type);

    if (pos == PRIMARY_CHUNKS_INV.end()) return ofs;
    
    WriteShortString(ofs, name);
    WritePrimitive<uint32_t>(ofs, pos->second);
    WritePrimitive<uint32_t>(ofs, offset);
    WritePrimitive<uint32_t>(ofs, size);

    return ofs;
}

std::ofstream& operator<<(std::ofstream& ofs, const Asset::Chunk& chunk)
{
    return chunk.operator<<(ofs);
}

void Asset::ReadInfoDat(augmented::ifstream& ifs)
{
    // Reading the name
    name = ReadShortString(ifs.FS());

    // Reading the file creation time
    time = ReadPrimitive<uint64_t>(ifs.FS());

    // Reading the chunk array
    {
        uint16_t n_chunks = ReadPrimitive<uint16_t>(ifs.FS());
        chunks.reserve(n_chunks);

        for (uint16_t i = 0; i < n_chunks; ++i)
        {
            chunks.emplace_back(ifs);
        }
    }
}

void Asset::GetFileAttrs(const std::string& file_path)
{
    using namespace std::chrono;
    using namespace std::filesystem;

    /* Delta between Windows' and Unix's zero times:
    12:00:00am the 1st of January 1601 and 
    12:00:00am the 1st of January 1970 respectfully. */
    const static uint64_t epoch_delta = 116'444'736'000'000'000;
    
    path file(file_path);
    size = file_size(file);

    time = duration_cast<nanoseconds>(clock_cast<system_clock>(last_write_time(file)).time_since_epoch()).count();
    time /= 100; // scaling to hundreds of nanoseconds
    time += epoch_delta; // shifting to Windows' zero time
}

void Asset::ReadInfoTex(augmented::ifstream& ifs)
{
    using namespace std::string_view_literals;
    
    name = ifs.FileStem();

    /* Setting the extension to be .tga
    regardless of the actual one (such is 
    the convention) */
    {
        // Checking if the file is .jpeg
        if (ifs.FileExt().size() == 5) name.pop_back();
        if (ifs.FileExt() != ".png"sv) name.replace(name.size() - 3, 3, "tga");
    }
    
    try
    {
        GetFileAttrs(ifs.FilePath());
    }
    catch(const std::exception& e)
    {
        std::cerr << e.what() << name << '\n';
    }
    
    chunks.emplace_back();
    chunks.back().name = name;
    chunks.back().type = ChunkType::W3D_TEXTURE_FILE;
}

void Asset::ReadInfoW3D(augmented::ifstream& ifs)
{
    name = ifs.FileStem();
    GetFileAttrs(ifs.FilePath());
    
    while (ifs.FS().tellg() < size)
    {
        try
        {
            chunks.emplace_back(ifs);
        }
        catch(const invalid_file_format& e)
        {
            throw invalid_file_format(e.what() + name);
        }
        catch(const std::runtime_error&)
        {}
    }
}

Asset::Asset(Asset&& other) noexcept
{
    swap(other);
}

Asset::Asset(augmented::ifstream& ifs)
{
    using namespace std::string_view_literals;

    if (ifs.FileExt() == ".dat"sv) ReadInfoDat(ifs);
    else if (ifs.FileExt() == ".w3d"sv) ReadInfoW3D(ifs);
    else ReadInfoTex(ifs);
}

void Asset::swap(Asset& other)
{
    std::swap(name, other.name);
    std::swap(time, other.time);
    std::swap(size, other.size);
    std::swap(chunks, other.chunks);
}

bool Asset::operator==(const Asset& other) const
{
    return name == other.name && 
        time == other.time;
}

bool Asset::operator<(const Asset& other) const
{
    return name == other.name && 
        time < other.time;
}

bool Asset::operator>(const Asset& other) const
{
    return name == other.name && 
        time > other.time;
}

augmented::ifstream& 
Asset::operator>>(augmented::ifstream& ifs)
{
    Asset temp(ifs);
    swap(temp);
    return ifs;
}

augmented::ifstream& 
operator>>(augmented::ifstream& ifs, Asset& asset)
{
    return asset.operator>>(ifs);
}

std::ofstream& Asset::operator<<(std::ofstream& ofs) const
{
    WriteShortString(ofs, name);
    WritePrimitive<uint64_t>(ofs, time);

    {
        WritePrimitive<uint16_t>(ofs, chunks.size());

        for (const Chunk& chunk : chunks)
        {
            ofs << chunk;
        }
    }

    return ofs;
}

std::ofstream& operator<<(std::ofstream& ofs, const Asset& asset)
{
    return asset.operator<<(ofs);
}